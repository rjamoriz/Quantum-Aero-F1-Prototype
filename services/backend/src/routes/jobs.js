/** * Job Orchestration API Routes * Manages simulation jobs across all services */const express = require('express');const router = express.Router();const Job = require('../models/Job');const { authenticateToken } = require('../middleware/auth');// Job status enumconst JobStatus = {  PENDING: 'pending',  RUNNING: 'running',  COMPLETED: 'completed',  FAILED: 'failed',  CANCELLED: 'cancelled'};// Job type enumconst JobType = {  ML_INFERENCE: 'ml_inference',  PHYSICS_VALIDATION: 'physics_validation',  QUANTUM_OPTIMIZATION: 'quantum_optimization',  TRANSIENT_SIMULATION: 'transient_simulation',  FSI_VALIDATION: 'fsi_validation',  MULTI_FIDELITY: 'multi_fidelity'};/** * GET /api/jobs * List all jobs with optional filtering and sorting */router.get('/', authenticateToken, async (req, res) => {  try {    const { filter, sortBy, limit = 50, skip = 0 } = req.query;        // Build query    let query = { userId: req.user.id };        if (filter && filter !== 'all') {      query.status = filter;    }        // Build sort    let sort = {};    switch (sortBy) {      case 'priority':        sort = { priority: -1, created: -1 };        break;      case 'status':        sort = { status: 1, created: -1 };        break;      case 'created':      default:        sort = { created: -1 };    }        const jobs = await Job.find(query)      .sort(sort)      .limit(parseInt(limit))      .skip(parseInt(skip));        const total = await Job.countDocuments(query);        res.json({      success: true,      jobs,      pagination: {        total,        limit: parseInt(limit),        skip: parseInt(skip),        hasMore: total > parseInt(skip) + parseInt(limit)      }    });  } catch (error) {    console.error('Error fetching jobs:', error);    res.status(500).json({      success: false,      error: 'Failed to fetch jobs'    });  }});/** * GET /api/jobs/:id * Get job details by ID */router.get('/:id', authenticateToken, async (req, res) => {  try {    const job = await Job.findOne({      _id: req.params.id,      userId: req.user.id    });        if (!job) {      return res.status(404).json({        success: false,        error: 'Job not found'      });    }        res.json({      success: true,      job    });  } catch (error) {    console.error('Error fetching job:', error);    res.status(500).json({      success: false,      error: 'Failed to fetch job'    });  }});/** * POST /api/jobs * Create a new job */router.post('/', authenticateToken, async (req, res) => {  try {    const { type, parameters, priority = 'medium' } = req.body;        // Validate job type    if (!Object.values(JobType).includes(type)) {      return res.status(400).json({        success: false,        error: `Invalid job type. Must be one of: ${Object.values(JobType).join(', ')}`      });    }        // Create job    const job = new Job({      userId: req.user.id,      type,      status: JobStatus.PENDING,      priority,      parameters,      created: new Date(),      progress: 0    });        await job.save();        // Queue job for processing (would integrate with Bull queue in production)    processJob(job._id);        res.status(201).json({      success: true,      job    });  } catch (error) {    console.error('Error creating job:', error);    res.status(500).json({      success: false,      error: 'Failed to create job'    });  }});/** * PUT /api/jobs/:id/retry * Retry a failed job */router.put('/:id/retry', authenticateToken, async (req, res) => {  try {    const job = await Job.findOne({      _id: req.params.id,      userId: req.user.id    });        if (!job) {      return res.status(404).json({        success: false,        error: 'Job not found'      });    }        if (job.status !== JobStatus.FAILED) {      return res.status(400).json({        success: false,        error: 'Only failed jobs can be retried'      });    }        // Reset job status    job.status = JobStatus.PENDING;    job.progress = 0;    job.error = null;    job.retryCount = (job.retryCount || 0) + 1;    job.retried = new Date();        await job.save();        // Re-queue job    processJob(job._id);        res.json({      success: true,      job    });  } catch (error) {    console.error('Error retrying job:', error);    res.status(500).json({      success: false,      error: 'Failed to retry job'    });  }});/** * DELETE /api/jobs/:id * Cancel a pending or running job */router.delete('/:id', authenticateToken, async (req, res) => {  try {    const job = await Job.findOne({      _id: req.params.id,      userId: req.user.id    });        if (!job) {      return res.status(404).json({        success: false,        error: 'Job not found'      });    }        if (job.status === JobStatus.COMPLETED) {      return res.status(400).json({        success: false,        error: 'Cannot cancel completed job'      });    }        // Cancel job    job.status = JobStatus.CANCELLED;    job.cancelled = new Date();        await job.save();        res.json({      success: true,      message: 'Job cancelled successfully'    });  } catch (error) {    console.error('Error cancelling job:', error);    res.status(500).json({      success: false,      error: 'Failed to cancel job'    });  }});/** * GET /api/jobs/:id/status * Get real-time job status (for polling) */router.get('/:id/status', authenticateToken, async (req, res) => {  try {    const job = await Job.findOne({      _id: req.params.id,      userId: req.user.id    }).select('status progress error result');        if (!job) {      return res.status(404).json({        success: false,        error: 'Job not found'      });    }        res.json({      success: true,      status: job.status,      progress: job.progress,      error: job.error,      result: job.result    });  } catch (error) {    console.error('Error fetching job status:', error);    res.status(500).json({      success: false,      error: 'Failed to fetch job status'    });  }});/** * Process job (simplified - would use Bull queue in production) */async function processJob(jobId) {  try {    const job = await Job.findById(jobId);    if (!job) return;        // Update to running    job.status = JobStatus.RUNNING;    job.started = new Date();    await job.save();        // Simulate job processing based on type    const processingTime = getProcessingTime(job.type);        // Simulate progress updates    const progressInterval = setInterval(async () => {      const currentJob = await Job.findById(jobId);      if (!currentJob || currentJob.status !== JobStatus.RUNNING) {        clearInterval(progressInterval);        return;      }            currentJob.progress = Math.min(currentJob.progress + 10, 90);      await currentJob.save();    }, processingTime / 10);        // Simulate completion    setTimeout(async () => {      clearInterval(progressInterval);            const currentJob = await Job.findById(jobId);      if (!currentJob || currentJob.status !== JobStatus.RUNNING) return;            // Simulate 90% success rate      if (Math.random() > 0.1) {        currentJob.status = JobStatus.COMPLETED;        currentJob.progress = 100;        currentJob.completed = new Date();        currentJob.duration = (currentJob.completed - currentJob.started) / 1000;        currentJob.result = generateMockResult(currentJob.type);      } else {        currentJob.status = JobStatus.FAILED;        currentJob.failed = new Date();        currentJob.error = 'Simulation failed: Solver divergence';      }            await currentJob.save();    }, processingTime);      } catch (error) {    console.error('Error processing job:', error);  }}function getProcessingTime(type) {  switch (type) {    case JobType.ML_INFERENCE:      return 2000; // 2 seconds    case JobType.PHYSICS_VALIDATION:      return 10000; // 10 seconds    case JobType.QUANTUM_OPTIMIZATION:      return 15000; // 15 seconds    case JobType.TRANSIENT_SIMULATION:      return 20000; // 20 seconds    case JobType.FSI_VALIDATION:      return 30000; // 30 seconds    default:      return 5000;  }}function generateMockResult(type) {  switch (type) {    case JobType.ML_INFERENCE:      return {        Cl: 2.8 + Math.random() * 0.2,        Cd: 0.42 + Math.random() * 0.05,        confidence: 0.9 + Math.random() * 0.1      };    case JobType.QUANTUM_OPTIMIZATION:      return {        solution: Array(20).fill(0).map(() => Math.random() > 0.5 ? 1 : 0),        energy: -3.14 + Math.random(),        iterations: Math.floor(Math.random() * 50) + 20      };    default:      return { success: true };  }}module.exports = router;