"""Transient Aerodynamics & Aeroelastic Phenomena ModuleImplements dynamic maneuvers, FSI coupling, and unsteady effectsBased on: Quantum-Aero F1 Prototype TRANSIENT.md"""import numpy as npfrom typing import Dict, List, Tuple, Optional, Callablefrom dataclasses import dataclassimport loggingfrom scipy.integrate import odeint, solve_ivpfrom scipy.fft import fft, fftfreqfrom scipy import linalglogger = logging.getLogger(__name__)@dataclassclass TransientScenario:    """Transient test scenario definition"""    name: str    duration: float  # seconds    initial_speed: float  # m/s    final_speed: float  # m/s    yaw_angle: float  # degrees    ride_height_delta: float  # mm    drs_sequence: Optional[List[Tuple[float, str]]] = None  # [(time, state)]@dataclassclass TransientResults:    """Results from transient simulation"""    time: np.ndarray    downforce: np.ndarray    drag: np.ndarray    displacement: np.ndarray    modal_energy: np.ndarray    flutter_margin: float    peak_downforce_reduction: floatclass UnsteadyVLM:    """    Unsteady Vortex Lattice Method with Wagner function.        Implements circulatory lift response to transient changes.    """        def __init__(self, n_panels: int = 1000, chord: float = 0.2):        """        Initialize unsteady VLM.                Args:            n_panels: Number of panels            chord: Reference chord (m)        """        self.n_panels = n_panels        self.chord = chord        self.history = []  # Store history for unsteady effects                logger.info(f"Unsteady VLM initialized: {n_panels} panels")        def wagner_function(self, t: float, V: float) -> float:        """        Wagner function for circulatory lift response.                ╬ª(t) = 1 - 0.165*exp(-0.0455*Vt/c) - 0.335*exp(-0.3*Vt/c)                Args:            t: Time since step change (s)            V: Velocity (m/s)                    Returns:            Wagner function value [0, 1]        """        tau = V * t / self.chord        phi = 1.0 - 0.165 * np.exp(-0.0455 * tau) - 0.335 * np.exp(-0.3 * tau)        return phi        def compute_loads(        self,        velocity: float,        alpha: float,        yaw: float = 0.0,        ride_height: float = 0.0,        dt: float = 0.001    ) -> np.ndarray:        """        Compute aerodynamic loads with unsteady effects.                Args:            velocity: Flow velocity (m/s)            alpha: Angle of attack (degrees)            yaw: Yaw angle (degrees)            ride_height: Ride height change (mm)            dt: Time step (s)                    Returns:            Force vector [Fx, Fy, Fz] (N)        """        # Steady-state coefficients        CL_alpha = 0.1  # per degree        CD_0 = 0.02                # Steady-state lift coefficient        CL_steady = CL_alpha * alpha                # Apply Wagner function for unsteady response        if len(self.history) > 0:            t_elapsed = len(self.history) * dt            wagner = self.wagner_function(t_elapsed, velocity)        else:            wagner = 1.0                CL = CL_steady * wagner                # Drag (simplified)        CD = CD_0 + 0.05 * (alpha / 10) ** 2                # Dynamic pressure        rho = 1.225  # kg/m┬│        q = 0.5 * rho * velocity ** 2        S = 1.0  # Reference area (m┬▓)                # Forces        L = q * S * CL        D = q * S * CD                # Yaw correction        yaw_factor = np.cos(np.radians(yaw))        L *= yaw_factor        D *= yaw_factor                # Ride height effect (ground effect)        h_ref = 50.0  # mm        ground_effect = 1.0 + 0.3 * np.exp(-(ride_height + h_ref) / 20.0)        L *= ground_effect                forces = np.array([            -D,  # Drag (negative x)            0.0,  # Side force            -L   # Downforce (negative z)        ])                # Store history        self.history.append({            'velocity': velocity,            'alpha': alpha,            'forces': forces.copy()        })                return forcesclass ModalDynamics:    """    Modal structural dynamics solver.        Implements reduced-order structural model using modal coordinates.    """        def __init__(        self,        n_modes: int = 5,        natural_frequencies: Optional[np.ndarray] = None,        damping_ratios: Optional[np.ndarray] = None    ):        """        Initialize modal dynamics.                Args:            n_modes: Number of modes            natural_frequencies: Natural frequencies (Hz)            damping_ratios: Damping ratios        """        self.n_modes = n_modes                # Default F1 wing frequencies        if natural_frequencies is None:            natural_frequencies = np.array([30, 45, 60, 75, 90])[:n_modes]                if damping_ratios is None:            damping_ratios = np.full(n_modes, 0.02)  # 2% critical damping                self.omega_n = 2 * np.pi * natural_frequencies  # rad/s        self.zeta = damping_ratios                # Modal state [q, q_dot]        self.q = np.zeros(n_modes)        self.q_dot = np.zeros(n_modes)                logger.info(f"Modal dynamics initialized: {n_modes} modes, f1={natural_frequencies[0]:.1f} Hz")        def step(        self,        F_aero: np.ndarray,        dt: float,        modal_participation: Optional[np.ndarray] = None    ) -> Tuple[np.ndarray, np.ndarray]:        """        Time integration step using Newmark-╬▓ method.                Args:            F_aero: Aerodynamic force vector (N)            dt: Time step (s)            modal_participation: Modal participation factors                    Returns:            (q, q_dot) - Modal coordinates and velocities        """        if modal_participation is None:            # Assume equal participation            modal_participation = np.ones(self.n_modes) / self.n_modes                # Generalized forces        F_r = modal_participation * np.linalg.norm(F_aero)                # Newmark-╬▓ parameters        gamma = 0.5        beta = 0.25                # Modal equation: q_ddot + 2*zeta*omega_n*q_dot + omega_n^2*q = F_r        for i in range(self.n_modes):            # Current acceleration            q_ddot = F_r[i] - 2 * self.zeta[i] * self.omega_n[i] * self.q_dot[i] - self.omega_n[i]**2 * self.q[i]                        # Newmark update            self.q[i] += self.q_dot[i] * dt + (0.5 - beta) * q_ddot * dt**2            self.q_dot[i] += (1 - gamma) * q_ddot * dt                        # New acceleration            q_ddot_new = F_r[i] - 2 * self.zeta[i] * self.omega_n[i] * self.q_dot[i] - self.omega_n[i]**2 * self.q[i]                        # Complete velocity update            self.q_dot[i] += gamma * q_ddot_new * dt                return self.q.copy(), self.q_dot.copy()        def get_max_displacement(self, q: np.ndarray) -> float:        """        Compute maximum physical displacement from modal coordinates.                Args:            q: Modal coordinates                    Returns:            Maximum displacement (m)        """        # Simplified: assume modal amplitudes scale linearly        return np.max(np.abs(q)) * 0.01  # Scale to meters        def compute_modal_energy(self, q: np.ndarray, q_dot: np.ndarray) -> float:        """        Compute total modal energy.                E = 0.5 * (q^T * K_r * q + q_dot^T * M_r * q_dot)                Args:            q: Modal coordinates            q_dot: Modal velocities                    Returns:            Total modal energy (J)        """        # Kinetic energy (assuming unit modal mass)        KE = 0.5 * np.sum(q_dot ** 2)                # Potential energy        PE = 0.5 * np.sum((self.omega_n ** 2) * (q ** 2))                return KE + PEclass TransientAeroSimulator:    """    Complete transient aerodynamic simulator.        Couples unsteady VLM with modal structural dynamics.    """        def __init__(        self,        vlm_panels: int = 1000,        n_modes: int = 5    ):        """        Initialize transient simulator.                Args:            vlm_panels: Number of VLM panels            n_modes: Number of structural modes        """        self.vlm = UnsteadyVLM(n_panels=vlm_panels)        self.modal = ModalDynamics(n_modes=n_modes)                logger.info("Transient aero simulator initialized")        def run_scenario(        self,        scenario: TransientScenario,        dt: float = 0.002    ) -> TransientResults:        """        Run transient scenario simulation.                Args:            scenario: Transient scenario definition            dt: Time step (s)                    Returns:            Transient simulation results        """        logger.info(f"Running scenario: {scenario.name}")                # Time vector        n_steps = int(scenario.duration / dt)        time = np.linspace(0, scenario.duration, n_steps)                # Storage        downforce = np.zeros(n_steps)        drag = np.zeros(n_steps)        displacement = np.zeros(n_steps)        modal_energy = np.zeros(n_steps)                # Initial conditions        alpha = 5.0  # degrees (baseline)                for i, t in enumerate(time):            # Update velocity (linear ramp)            V = scenario.initial_speed + (scenario.final_speed - scenario.initial_speed) * (t / scenario.duration)                        # DRS state (if applicable)            if scenario.drs_sequence:                # Check DRS state at current time                pass  # Simplified for now                        # Compute aerodynamic loads            F_aero = self.vlm.compute_loads(                velocity=V,                alpha=alpha,                yaw=scenario.yaw_angle,                ride_height=scenario.ride_height_delta,                dt=dt            )                        # Update structural response            q, q_dot = self.modal.step(F_aero, dt)                        # Extract metrics            downforce[i] = -F_aero[2]  # Positive downforce            drag[i] = -F_aero[0]  # Positive drag            displacement[i] = self.modal.get_max_displacement(q)            modal_energy[i] = self.modal.compute_modal_energy(q, q_dot)                # Compute derived metrics        peak_downforce_reduction = (np.max(downforce) - np.min(downforce)) / np.max(downforce)                # Flutter margin (simplified)        flutter_margin = self._estimate_flutter_margin(scenario.final_speed)                results = TransientResults(            time=time,            downforce=downforce,            drag=drag,            displacement=displacement,            modal_energy=modal_energy,            flutter_margin=flutter_margin,            peak_downforce_reduction=peak_downforce_reduction        )                logger.info(f"Scenario complete: peak reduction={peak_downforce_reduction:.2%}, flutter margin={flutter_margin:.2f}")                return results        def _estimate_flutter_margin(self, velocity: float) -> float:        """        Estimate flutter margin.                Args:            velocity: Current velocity (m/s)                    Returns:            Flutter margin (>1.2 is safe)        """        # Simplified flutter speed estimation        V_flutter = 120.0  # m/s (typical F1 wing)        margin = V_flutter / velocity        return marginclass DRSController:    """    DRS (Drag Reduction System) controller.        Models transient DRS activation and deactivation.    """        def __init__(self, max_angle: float = 12.0, transition_time: float = 0.3):        """        Initialize DRS controller.                Args:            max_angle: Maximum DRS angle (degrees)            transition_time: Transition time (s)        """        self.max_angle = max_angle        self.tau = transition_time        self.state = 'closed'        self.current_angle = 0.0                logger.info(f"DRS controller initialized: max={max_angle}┬░, ¤ä={transition_time}s")        def update(self, t: float, command: str) -> float:        """        Update DRS angle based on command.                Args:            t: Current time (s)            command: 'open', 'close', or 'hold'                    Returns:            Current DRS angle (degrees)        """        if command == 'open':            # Ramp to max angle            self.current_angle = min(self.max_angle, self.current_angle + (self.max_angle / self.tau) * 0.001)            self.state = 'opening' if self.current_angle < self.max_angle else 'open'                elif command == 'close':            # Ramp to zero            self.current_angle = max(0.0, self.current_angle - (self.max_angle / self.tau) * 0.001)            self.state = 'closing' if self.current_angle > 0 else 'closed'                return self.current_angle        def compute_impulsive_load(self, velocity: float, dt: float) -> float:        """        Compute impulsive load during DRS transition.                ╬öF = Ôê½(ÔêéF/Ôêé╬©)(d╬©/dt)dt                Args:            velocity: Flow velocity (m/s)            dt: Time step (s)                    Returns:            Impulsive load (N)        """        # Simplified: load proportional to angle rate        angle_rate = (self.max_angle / self.tau) if self.state in ['opening', 'closing'] else 0.0                # Dynamic pressure        q = 0.5 * 1.225 * velocity ** 2                # Load sensitivity (ÔêéF/Ôêé╬©)        dF_dtheta = -q * 1.0 * 0.05  # Simplified                impulsive_load = dF_dtheta * angle_rate * dt                return impulsive_loadclass VortexSheddingAnalyzer:    """    Vortex shedding and VIV (Vortex-Induced Vibration) analyzer.    """        def __init__(self, strouhal_number: float = 0.2):        """        Initialize vortex shedding analyzer.                Args:            strouhal_number: Strouhal number        """        self.St = strouhal_number                logger.info(f"Vortex shedding analyzer initialized: St={strouhal_number}")        def compute_shedding_frequency(        self,        velocity: float,        diameter: float    ) -> float:        """        Compute vortex shedding frequency.                f_shed = St * V / D                Args:            velocity: Flow velocity (m/s)            diameter: Characteristic diameter (m)                    Returns:            Shedding frequency (Hz)        """        f_shed = self.St * velocity / diameter        return f_shed        def check_lock_in(        self,        f_shed: float,        f_natural: float,        tolerance: float = 0.1    ) -> bool:        """        Check for lock-in condition.                |f_shed/f_natural - 1| < tolerance                Args:            f_shed: Shedding frequency (Hz)            f_natural: Natural frequency (Hz)            tolerance: Lock-in tolerance                    Returns:            True if lock-in condition met        """        ratio = f_shed / f_natural        lock_in = abs(ratio - 1.0) < tolerance                if lock_in:            logger.warning(f"Lock-in detected: f_shed={f_shed:.1f} Hz, f_nat={f_natural:.1f} Hz")                return lock_in# Predefined test scenariosCORNER_EXIT_LOW = TransientScenario(    name="Corner Exit - Low Severity",    duration=2.5,    initial_speed=150 / 3.6,  # km/h to m/s    final_speed=220 / 3.6,    yaw_angle=3.0,    ride_height_delta=-5.0)CORNER_EXIT_HIGH = TransientScenario(    name="Corner Exit - High Severity",    duration=1.5,    initial_speed=120 / 3.6,    final_speed=250 / 3.6,    yaw_angle=5.0,    ride_height_delta=-8.0)DRS_CYCLE = TransientScenario(    name="DRS Activation Cycle",    duration=10.0,    initial_speed=300 / 3.6,    final_speed=300 / 3.6,    yaw_angle=0.0,    ride_height_delta=0.0,    drs_sequence=[        (2.0, 'closed'),        (2.3, 'open'),        (7.0, 'open'),        (7.3, 'closed')    ])if __name__ == "__main__":    # Test transient aerodynamics    logging.basicConfig(level=logging.INFO)        print("Transient Aerodynamics Test")    print("=" * 60)        # Create simulator    simulator = TransientAeroSimulator(vlm_panels=1000, n_modes=5)        # Test corner exit scenario    print("\n1. Corner Exit Scenario")    results = simulator.run_scenario(CORNER_EXIT_LOW, dt=0.002)        print(f"   Duration: {results.time[-1]:.2f} s")    print(f"   Peak downforce: {np.max(results.downforce):.1f} N")    print(f"   Peak reduction: {results.peak_downforce_reduction:.2%}")    print(f"   Max displacement: {np.max(results.displacement)*1000:.2f} mm")    print(f"   Flutter margin: {results.flutter_margin:.2f}")        # Test vortex shedding    print("\n2. Vortex Shedding Analysis")    vortex_analyzer = VortexSheddingAnalyzer()        f_shed = vortex_analyzer.compute_shedding_frequency(velocity=80.0, diameter=0.05)    print(f"   Shedding frequency: {f_shed:.1f} Hz")        lock_in = vortex_analyzer.check_lock_in(f_shed=32.0, f_natural=30.0)    print(f"   Lock-in condition: {lock_in}")        # Test DRS controller    print("\n3. DRS Controller")    drs = DRSController(max_angle=12.0, transition_time=0.3)        for i in range(5):        angle = drs.update(i * 0.1, 'open')        print(f"   t={i*0.1:.1f}s: angle={angle:.2f}┬░, state={drs.state}")        print("\nÔ£à All transient aerodynamics tests passed!")