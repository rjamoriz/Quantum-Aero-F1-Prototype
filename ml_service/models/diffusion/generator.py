"""Diffusion-based Geometry GeneratorGenerate F1 wing geometries from aerodynamic specifications"""import torchimport torch.nn as nnimport numpy as npfrom typing import Dict, Any, List, Optionalimport timefrom tqdm import tqdmfrom .model import AeroDiffusionUNet, DiffusionSchedulerclass AeroGeometryGenerator:    """    Generate 3D aerodynamic geometries using diffusion models        Target: 5-second generation, 1000+ candidates/day    """        def __init__(        self,        model_path: Optional[str] = None,        device: str = 'cuda' if torch.cuda.is_available() else 'cpu'    ):        self.device = torch.device(device)                # Initialize model        self.model = AeroDiffusionUNet(            in_channels=1,            out_channels=1,            base_channels=64,            time_emb_dim=256,            cond_dim=16        ).to(self.device)                # Initialize scheduler        self.scheduler = DiffusionScheduler(num_timesteps=1000)                # Load pretrained weights if available        if model_path:            self.load_model(model_path)                self.model.eval()                print(f"AeroGeometryGenerator initialized on {device}")        def load_model(self, path: str):        """Load pretrained model"""        checkpoint = torch.load(path, map_location=self.device)        self.model.load_state_dict(checkpoint['model_state_dict'])        print(f"Loaded model from {path}")        def encode_aerodynamic_targets(        self,        cl: float = 2.8,        cd: float = 0.4,        cm: float = -0.1,        volume: float = 0.5,        thickness: float = 0.12,        camber: float = 0.04,        span: float = 2.0,        chord: float = 1.0    ) -> torch.Tensor:        """        Encode aerodynamic targets as condition vector                Returns:            (1, 16) condition tensor        """        condition = torch.tensor([            cl / 3.0,  # Normalize            cd / 1.0,            cm / 0.5,            volume,            thickness / 0.2,            camber / 0.1,            span / 3.0,            chord / 2.0,            # Additional features            cl / cd if cd > 0 else 0,  # L/D ratio            np.sqrt(cl**2 + cd**2),  # Magnitude            np.arctan2(cd, cl),  # Angle            cl * span,  # Total lift            cd * span,  # Total drag            volume * thickness,  # Volume metric            camber / thickness if thickness > 0 else 0,  # Shape ratio            span / chord  # Aspect ratio        ], dtype=torch.float32).unsqueeze(0)                return condition.to(self.device)        @torch.no_grad()    def generate(        self,        cl: float = 2.8,        cd: float = 0.4,        cm: float = -0.1,        volume: float = 0.5,        thickness: float = 0.12,        camber: float = 0.04,        span: float = 2.0,        chord: float = 1.0,        num_inference_steps: int = 50,        guidance_scale: float = 7.5,        return_timing: bool = False    ) -> Dict[str, Any]:        """        Generate 3D geometry from aerodynamic specifications                Args:            cl: Target lift coefficient            cd: Target drag coefficient            cm: Target moment coefficient            volume: Target volume constraint            thickness: Target thickness            camber: Target camber            span: Wing span            chord: Wing chord            num_inference_steps: Number of denoising steps            guidance_scale: Classifier-free guidance scale            return_timing: Return timing information                Returns:            Dictionary with geometry and metadata        """        start_time = time.time()                # Encode conditions        condition = self.encode_aerodynamic_targets(            cl, cd, cm, volume, thickness, camber, span, chord        )                # Start from random noise        geometry_shape = (1, 1, 64, 64, 64)        x_t = torch.randn(geometry_shape, device=self.device)                # Denoising loop        timesteps = torch.linspace(            self.scheduler.num_timesteps - 1, 0,            num_inference_steps, dtype=torch.long        )                for i, t in enumerate(tqdm(timesteps, desc="Generating", disable=not return_timing)):            t_tensor = torch.full((1,), t, device=self.device, dtype=torch.long)                        # Predict noise            noise_pred = self.model(x_t, t_tensor, condition)                        # Classifier-free guidance (if enabled)            if guidance_scale > 1.0:                # Unconditional prediction                uncond_condition = torch.zeros_like(condition)                noise_pred_uncond = self.model(x_t, t_tensor, uncond_condition)                                # Apply guidance                noise_pred = noise_pred_uncond + guidance_scale * (noise_pred - noise_pred_uncond)                        # Denoise            x_t = self.scheduler.denoise_step(                lambda x, t, c: noise_pred,                x_t, int(t), condition            )                # Final geometry        geometry = x_t.cpu().numpy()[0, 0]                # Post-process (threshold to binary)        geometry = (geometry > 0).astype(np.float32)                generation_time = time.time() - start_time                result = {            'geometry': geometry,            'shape': geometry.shape,            'parameters': {                'cl': cl,                'cd': cd,                'cm': cm,                'volume': volume,                'thickness': thickness,                'camber': camber,                'span': span,                'chord': chord            },            'num_inference_steps': num_inference_steps,            'guidance_scale': guidance_scale        }                if return_timing:            result['generation_time_s'] = generation_time            result['target_met'] = generation_time < 5.0                return result        def generate_batch(        self,        specifications: List[Dict[str, float]],        num_inference_steps: int = 50    ) -> List[Dict[str, Any]]:        """        Generate multiple geometries in batch                Args:            specifications: List of aerodynamic specifications            num_inference_steps: Number of denoising steps                Returns:            List of generated geometries        """        results = []                for spec in tqdm(specifications, desc="Batch generation"):            result = self.generate(**spec, num_inference_steps=num_inference_steps)            results.append(result)                return results        def optimize_for_targets(        self,        target_cl: float = 2.8,        target_cd: float = 0.4,        num_candidates: int = 100,        num_inference_steps: int = 25    ) -> List[Dict[str, Any]]:        """        Generate multiple candidates and select best                Target: 1000+ candidates/day                Args:            target_cl: Target lift coefficient            target_cd: Target drag coefficient            num_candidates: Number of candidates to generate            num_inference_steps: Denoising steps (reduced for speed)                Returns:            List of candidate geometries sorted by quality        """        print(f"Generating {num_candidates} candidates...")        start_time = time.time()                candidates = []                for i in range(num_candidates):            # Add variation            cl_var = target_cl + np.random.randn() * 0.1            cd_var = target_cd + np.random.randn() * 0.02                        result = self.generate(                cl=cl_var,                cd=cd_var,                num_inference_steps=num_inference_steps,                return_timing=False            )                        # Compute quality score (simplified)            cl_error = abs(cl_var - target_cl)            cd_error = abs(cd_var - target_cd)            quality = 1.0 / (1.0 + cl_error + cd_error * 5)                        result['quality_score'] = quality            result['candidate_id'] = i                        candidates.append(result)                # Sort by quality        candidates.sort(key=lambda x: x['quality_score'], reverse=True)                total_time = time.time() - start_time        candidates_per_day = (num_candidates / total_time) * 86400                print(f"Generated {num_candidates} candidates in {total_time:.2f}s")        print(f"Rate: {candidates_per_day:.0f} candidates/day")        print(f"Target met: {candidates_per_day >= 1000}")                return candidates        def export_to_mesh(        self,        geometry: np.ndarray,        output_path: str,        format: str = 'stl'    ):        """        Export geometry to mesh file (STL, STEP, etc.)                Args:            geometry: 3D geometry array            output_path: Output file path            format: Export format ('stl', 'step', 'iges')        """        # Placeholder for mesh export        # Would use libraries like trimesh, pymesh, or CAD kernels        print(f"Exporting to {format.upper()} format...")        print(f"Output: {output_path}")        print("Note: Mesh export requires additional CAD libraries")if __name__ == "__main__":    # Test generator    print("Testing Aerodynamic Geometry Generator\n")        generator = AeroGeometryGenerator()        # Single generation    print("\n1. Single geometry generation:")    result = generator.generate(        cl=2.8,        cd=0.4,        cm=-0.1,        num_inference_steps=50,        return_timing=True    )        print(f"  Geometry shape: {result['shape']}")    print(f"  Generation time: {result['generation_time_s']:.2f}s")    print(f"  Target (<5s): {'Ô£ô' if result['target_met'] else 'Ô£ù'}")        # Batch generation    print("\n2. Batch generation (10 candidates):")    specs = [        {'cl': 2.8 + i * 0.1, 'cd': 0.4, 'num_inference_steps': 25}        for i in range(10)    ]        batch_results = generator.generate_batch(specs)    print(f"  Generated: {len(batch_results)} geometries")        # Optimization    print("\n3. Candidate optimization:")    candidates = generator.optimize_for_targets(        target_cl=2.8,        target_cd=0.4,        num_candidates=50,        num_inference_steps=25    )        print(f"\nTop 5 candidates:")    for i, cand in enumerate(candidates[:5]):        print(f"  {i+1}. Quality: {cand['quality_score']:.4f}, "              f"Cl: {cand['parameters']['cl']:.2f}, "              f"Cd: {cand['parameters']['cd']:.3f}")        print("\nÔ£ô Generator test complete!")