"""AeroGAN APIFastAPI service for StyleGAN3-based aerodynamic design"""from fastapi import FastAPI, HTTPExceptionfrom pydantic import BaseModelfrom typing import Dict, Any, List, Optionalimport torchimport numpy as npfrom .generator import AeroGANGeneratorfrom .discriminator import AeroGANDiscriminator# Initialize FastAPI appapp = FastAPI(title="AeroGAN API", version="1.0.0")# Global instancesgenerator: Optional[AeroGANGenerator] = Nonediscriminator: Optional[AeroGANDiscriminator] = Nonedevice: torch.device = None# Request/Response Modelsclass GenerateRequest(BaseModel):    cl: float = 2.8    cd: float = 0.4    cm: float = -0.1    volume: float = 0.5    thickness: float = 0.12    camber: float = 0.04    span: float = 2.0    chord: float = 1.0    num_samples: int = 1    truncation_psi: float = 0.7    seed: Optional[int] = Noneclass GenerateResponse(BaseModel):    num_generated: int    resolution: int    truncation_psi: float    condition: Dict[str, float]    predicted_physics: List[Dict[str, float]]class InterpolateRequest(BaseModel):    start_condition: Dict[str, float]    end_condition: Dict[str, float]    num_steps: int = 10    truncation_psi: float = 0.7class EvaluateRequest(BaseModel):    target_cl: float = 2.8    target_cd: float = 0.4    target_cm: float = -0.1# API Endpoints@app.on_event("startup")async def startup_event():    """Initialize models on startup"""    global generator, discriminator, device        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')        # Initialize generator    generator = AeroGANGenerator(        z_dim=512,        w_dim=512,        condition_dim=16,        resolution=64    ).to(device)        # Initialize discriminator    discriminator = AeroGANDiscriminator(        resolution=64,        condition_dim=16    ).to(device)        # Try to load pretrained models    try:        checkpoint = torch.load("models/aerogan_generator.pt", map_location=device)        generator.load_state_dict(checkpoint['generator_state_dict'])        print("Ô£ô Loaded pretrained AeroGAN generator")    except:        print("Ô£ô AeroGAN generator initialized (no pretrained model)")        try:        checkpoint = torch.load("models/aerogan_discriminator.pt", map_location=device)        discriminator.load_state_dict(checkpoint['discriminator_state_dict'])        print("Ô£ô Loaded pretrained AeroGAN discriminator")    except:        print("Ô£ô AeroGAN discriminator initialized (no pretrained model)")@app.get("/")async def root():    """API root"""    return {        "service": "AeroGAN API",        "version": "1.0.0",        "status": "ready",        "description": "StyleGAN3-based generative design for aerodynamics"    }def encode_condition(    cl: float, cd: float, cm: float,    volume: float, thickness: float, camber: float,    span: float, chord: float) -> torch.Tensor:    """Encode aerodynamic condition"""    condition = torch.tensor([        cl / 3.0,        cd / 1.0,        cm / 0.5,        volume,        thickness / 0.2,        camber / 0.1,        span / 3.0,        chord / 2.0,        cl / cd if cd > 0 else 0,        np.sqrt(cl**2 + cd**2),        np.arctan2(cd, cl),        cl * span,        cd * span,        volume * thickness,        camber / thickness if thickness > 0 else 0,        span / chord    ], dtype=torch.float32).unsqueeze(0)        return condition.to(device)@app.post("/api/ml/aerogan/generate", response_model=GenerateResponse)async def generate_designs(request: GenerateRequest):    """    Generate aerodynamic designs using StyleGAN3        Produces high-quality, diverse geometries    """    if generator is None or discriminator is None:        raise HTTPException(status_code=503, detail="Models not initialized")        try:        # Set seed if provided        if request.seed is not None:            torch.manual_seed(request.seed)            np.random.seed(request.seed)                # Encode condition        condition = encode_condition(            request.cl, request.cd, request.cm,            request.volume, request.thickness, request.camber,            request.span, request.chord        )                # Repeat for batch        condition = condition.repeat(request.num_samples, 1)                # Generate        sdf = generator.generate(            batch_size=request.num_samples,            condition=condition,            truncation_psi=request.truncation_psi,            device=device        )                # Evaluate with discriminator        with torch.no_grad():            _, predicted_physics = discriminator(sdf, condition)                # Parse predictions        predicted_physics_list = []        for i in range(request.num_samples):            pred = predicted_physics[i].cpu().numpy()            predicted_physics_list.append({                'cl': float(pred[0]),                'cd': float(pred[1]),                'cm': float(pred[2])            })                return GenerateResponse(            num_generated=request.num_samples,            resolution=64,            truncation_psi=request.truncation_psi,            condition={                'cl': request.cl,                'cd': request.cd,                'cm': request.cm,                'volume': request.volume,                'thickness': request.thickness,                'camber': request.camber,                'span': request.span,                'chord': request.chord            },            predicted_physics=predicted_physics_list        )            except Exception as e:        raise HTTPException(status_code=500, detail=str(e))@app.post("/api/ml/aerogan/interpolate")async def interpolate_designs(request: InterpolateRequest):    """    Interpolate between two aerodynamic designs        Smooth morphing in latent space    """    if generator is None:        raise HTTPException(status_code=503, detail="Generator not initialized")        try:        # Encode start and end conditions        start_cond = encode_condition(**request.start_condition)        end_cond = encode_condition(**request.end_condition)                # Generate latent codes        z_start = torch.randn(1, 512, device=device)        z_end = torch.randn(1, 512, device=device)                # Interpolate        interpolations = []                for i in range(request.num_steps):            alpha = i / (request.num_steps - 1)                        # Interpolate latent code            z = (1 - alpha) * z_start + alpha * z_end                        # Interpolate condition            cond = (1 - alpha) * start_cond + alpha * end_cond                        # Generate            with torch.no_grad():                sdf = generator(z, cond, request.truncation_psi)                _, physics = discriminator(sdf, cond)                        interpolations.append({                'step': i,                'alpha': alpha,                'predicted_cl': float(physics[0, 0].cpu()),                'predicted_cd': float(physics[0, 1].cpu()),                'predicted_cm': float(physics[0, 2].cpu())            })                return {            'num_steps': request.num_steps,            'interpolations': interpolations        }            except Exception as e:        raise HTTPException(status_code=500, detail=str(e))@app.post("/api/ml/aerogan/evaluate")async def evaluate_design(request: EvaluateRequest):    """    Evaluate generated design quality        Physics-informed quality assessment    """    if discriminator is None:        raise HTTPException(status_code=503, detail="Discriminator not initialized")        try:        # Generate random design        condition = encode_condition(            request.target_cl, request.target_cd, request.target_cm,            0.5, 0.12, 0.04, 2.0, 1.0        )                z = torch.randn(1, 512, device=device)                with torch.no_grad():            sdf = generator(z, condition)            validity, physics = discriminator(sdf, condition)                # Compute errors        cl_error = abs(physics[0, 0].item() - request.target_cl)        cd_error = abs(physics[0, 1].item() - request.target_cd)        cm_error = abs(physics[0, 2].item() - request.target_cm)                quality_score = 1.0 / (1.0 + cl_error + cd_error * 5 + cm_error * 2)                return {            'validity_score': float(validity[0, 0].cpu()),            'predicted_cl': float(physics[0, 0].cpu()),            'predicted_cd': float(physics[0, 1].cpu()),            'predicted_cm': float(physics[0, 2].cpu()),            'target_cl': request.target_cl,            'target_cd': request.target_cd,            'target_cm': request.target_cm,            'cl_error': cl_error,            'cd_error': cd_error,            'cm_error': cm_error,            'quality_score': quality_score        }            except Exception as e:        raise HTTPException(status_code=500, detail=str(e))@app.get("/api/ml/aerogan/capabilities")async def get_capabilities():    """Get AeroGAN capabilities"""    return {        'architecture': 'StyleGAN3-inspired',        'generator': {            'latent_dim': 512,            'intermediate_dim': 512,            'resolution': '64┬│',            'output': 'SDF (Signed Distance Field)',            'conditioning': '16-dimensional'        },        'discriminator': {            'architecture': 'ResNet3D',            'outputs': ['validity', 'physics'],            'physics_prediction': ['Cl', 'Cd', 'Cm']        },        'features': [            'Style modulation',            'Truncation trick',            'Latent space interpolation',            'Physics-informed training',            'Conditional generation'        ],        'quality_control': {            'truncation_psi': [0.0, 1.0],            'default': 0.7,            'effect': 'quality vs diversity tradeoff'        }    }if __name__ == "__main__":    import uvicorn    uvicorn.run(app, host="0.0.0.0", port=8009)